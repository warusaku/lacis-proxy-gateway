---
title: LacisProxyGateway データ管理仕様書
projects:
- LPG
tags:
- '#proj-lpg'
created: '2025-07-28'
updated: '2025-07-28'
author: unknown
status: draft
---
# LacisProxyGateway データ管理仕様書

**― 設定・ログデータ管理設計書 ―**  
作成日: 2025-07-26  
バージョン: 1.0.0

---

## 1. 概要

### 1.1 データ管理方針

| 項目 | 内容 |
|------|------|
| 設定データ | JSONファイル形式（単一ファイル） |
| ログデータ | JSONライン形式（ローテーション） |
| バックアップ | 世代管理（最大5世代） |
| 同期方式 | ファイルベース + メモリキャッシュ |
| ロック方式 | ファイルロック + アプリケーションレベルミューテックス |

### 1.2 ディレクトリ構造

```
/etc/lpg/
├── config.json           # メイン設定ファイル
├── config.schema.json    # JSONスキーマ定義
├── backups/             # バックアップディレクトリ
│   ├── config_v1.json
│   ├── config_v2.json
│   └── ...
└── .lock                # ロックファイル

/var/log/lpg/
├── access.log           # アクセスログ（現在）
├── access.log.1         # ローテーション済み
├── api.log             # APIサーバーログ
├── caddy.log           # Caddyログ
└── system.log          # システムログ

/var/lib/lpg/
├── cache/              # キャッシュディレクトリ
├── temp/               # 一時ファイル
└── state.json          # 状態管理ファイル
```

---

## 2. 設定データ管理

### 2.1 config.json構造

```json
{
  "$schema": "./config.schema.json",
  "version": "1.0.0",
  "metadata": {
    "created": "2025-07-26T00:00:00+09:00",
    "modified": "2025-07-26T12:34:56+09:00",
    "modifiedBy": "lacisadmin",
    "revision": 3
  },
  "hostdomains": {
    "lacisstack.ath.cx": "192.168.234.0/24",
    "example.com": "192.168.123.0/24"
  },
  "hostingdevice": {
    "lacisstack.ath.cx": {
      "": {
        "deviceip": "",
        "port": [],
        "sitename": "",
        "ips": []
      },
      "/board": {
        "deviceip": "192.168.234.10",
        "port": [8080, 8443],
        "sitename": "whiteboard",
        "ips": ["any"]
      }
    }
  },
  "adminuser": {
    "lacisadmin": "$argon2id$v=19$m=65536,t=3,p=4$..."
  },
  "endpoint": {
    "logserver": "https://www.example.com/logs"
  },
  "options": {
    "websocket_timeout": 600,
    "log_retention_days": 30,
    "session_timeout": 86400,
    "max_request_size": 10485760,
    "rate_limit": {
      "requests_per_minute": 60,
      "burst": 120
    }
  }
}
```

### 2.2 JSONスキーマ定義

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "LPG Configuration Schema",
  "type": "object",
  "required": ["version", "metadata", "hostdomains", "hostingdevice", "adminuser"],
  "properties": {
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$"
    },
    "metadata": {
      "type": "object",
      "required": ["created", "modified", "modifiedBy", "revision"],
      "properties": {
        "created": { "type": "string", "format": "date-time" },
        "modified": { "type": "string", "format": "date-time" },
        "modifiedBy": { "type": "string" },
        "revision": { "type": "integer", "minimum": 1 }
      }
    },
    "hostdomains": {
      "type": "object",
      "patternProperties": {
        "^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?(\\.[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?)*$": {
          "type": "string",
          "pattern": "^([0-9]{1,3}\\.){3}[0-9]{1,3}/[0-9]{1,2}$"
        }
      }
    },
    "hostingdevice": {
      "type": "object",
      "patternProperties": {
        ".*": {
          "type": "object",
          "patternProperties": {
            "^(/.*)?$": {
              "type": "object",
              "required": ["deviceip", "port", "sitename", "ips"],
              "properties": {
                "deviceip": {
                  "type": "string",
                  "pattern": "^(([0-9]{1,3}\\.){3}[0-9]{1,3})?$"
                },
                "port": {
                  "type": "array",
                  "items": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 65535
                  }
                },
                "sitename": { "type": "string" },
                "ips": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "pattern": "^(any|([0-9]{1,3}\\.){3}[0-9]{1,3}/[0-9]{1,2})$"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
```

### 2.3 設定ファイル操作

#### 読み込み処理

```go
type ConfigManager struct {
    mu           sync.RWMutex
    config       *Config
    lastModified time.Time
    filePath     string
}

func (cm *ConfigManager) Load() error {
    cm.mu.Lock()
    defer cm.mu.Unlock()
    
    // ファイルロック取得
    lockFile := cm.filePath + ".lock"
    lock, err := lockfile.New(lockFile)
    if err != nil {
        return err
    }
    
    if err := lock.TryLock(); err != nil {
        return fmt.Errorf("設定ファイルがロックされています: %w", err)
    }
    defer lock.Unlock()
    
    // ファイル読み込み
    data, err := os.ReadFile(cm.filePath)
    if err != nil {
        return err
    }
    
    // JSONスキーマ検証
    if err := cm.validateSchema(data); err != nil {
        return fmt.Errorf("スキーマ検証エラー: %w", err)
    }
    
    // パース
    var config Config
    if err := json.Unmarshal(data, &config); err != nil {
        return err
    }
    
    cm.config = &config
    cm.lastModified = time.Now()
    
    return nil
}
```

#### 書き込み処理

```go
func (cm *ConfigManager) Save(config *Config) error {
    cm.mu.Lock()
    defer cm.mu.Unlock()
    
    // バックアップ作成
    if err := cm.createBackup(); err != nil {
        return fmt.Errorf("バックアップ作成エラー: %w", err)
    }
    
    // メタデータ更新
    config.Metadata.Modified = time.Now()
    config.Metadata.Revision++
    
    // JSON生成（整形）
    data, err := json.MarshalIndent(config, "", "  ")
    if err != nil {
        return err
    }
    
    // アトミック書き込み
    tempFile := cm.filePath + ".tmp"
    if err := os.WriteFile(tempFile, data, 0600); err != nil {
        return err
    }
    
    if err := os.Rename(tempFile, cm.filePath); err != nil {
        return err
    }
    
    cm.config = config
    cm.lastModified = time.Now()
    
    return nil
}
```

### 2.4 バックアップ管理

#### バックアップ作成

```go
func (cm *ConfigManager) createBackup() error {
    // 現在の設定を読み込み
    current, err := os.ReadFile(cm.filePath)
    if err != nil {
        return err
    }
    
    // バックアップファイル名生成
    backupDir := filepath.Dir(cm.filePath) + "/backups"
    os.MkdirAll(backupDir, 0700)
    
    backupFile := fmt.Sprintf("%s/config_v%d.json", 
        backupDir, cm.config.Metadata.Revision)
    
    // バックアップ作成
    if err := os.WriteFile(backupFile, current, 0600); err != nil {
        return err
    }
    
    // 古いバックアップを削除（5世代保持）
    return cm.cleanOldBackups(backupDir, 5)
}
```

#### リストア処理

```go
func (cm *ConfigManager) Restore(version int) error {
    backupFile := fmt.Sprintf("%s/backups/config_v%d.json", 
        filepath.Dir(cm.filePath), version)
    
    // バックアップファイル読み込み
    data, err := os.ReadFile(backupFile)
    if err != nil {
        return fmt.Errorf("バックアップファイルが見つかりません: v%d", version)
    }
    
    // 検証
    if err := cm.validateSchema(data); err != nil {
        return fmt.Errorf("バックアップファイルが破損しています: %w", err)
    }
    
    // 現在の設定をバックアップ
    if err := cm.createBackup(); err != nil {
        return err
    }
    
    // リストア実行
    return os.WriteFile(cm.filePath, data, 0600)
}
```

---

## 3. ログデータ管理

### 3.1 ログフォーマット

#### アクセスログ

```json
{
  "timestamp": "2025-07-26T12:34:56.789+09:00",
  "host": "lacisstack.ath.cx",
  "path": "/board",
  "method": "GET",
  "status": 200,
  "bytes": 12345,
  "duration": 123,
  "ip": "192.168.1.100",
  "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)...",
  "sitename": "whiteboard",
  "upstream": "192.168.234.10:8080",
  "protocol": "HTTP/1.1",
  "tls": {
    "version": "TLS1.3",
    "cipher": "TLS_AES_256_GCM_SHA384"
  }
}
```

#### システムログ

```json
{
  "timestamp": "2025-07-26T12:34:56.789+09:00",
  "level": "INFO",
  "component": "api",
  "message": "設定を更新しました",
  "details": {
    "user": "lacisadmin",
    "action": "config_update",
    "changes": ["domains", "devices"]
  }
}
```

### 3.2 ログローテーション

#### ローテーション設定

```go
type LogRotator struct {
    MaxSize    int64         // 最大サイズ (bytes)
    MaxAge     time.Duration // 最大保持期間
    MaxBackups int          // 最大バックアップ数
    Compress   bool         // 圧縮するか
}

func NewLogRotator() *LogRotator {
    return &LogRotator{
        MaxSize:    300 * 1024, // 300KB
        MaxAge:     30 * 24 * time.Hour,
        MaxBackups: 5,
        Compress:   true,
    }
}
```

#### ローテーション処理

```go
func (lr *LogRotator) Rotate(logFile string) error {
    info, err := os.Stat(logFile)
    if err != nil {
        return err
    }
    
    // サイズチェック
    if info.Size() < lr.MaxSize {
        return nil
    }
    
    // ローテーション実行
    timestamp := time.Now().Format("20060102_150405")
    rotatedFile := fmt.Sprintf("%s.%s", logFile, timestamp)
    
    if err := os.Rename(logFile, rotatedFile); err != nil {
        return err
    }
    
    // 圧縮
    if lr.Compress {
        if err := lr.compressFile(rotatedFile); err != nil {
            return err
        }
    }
    
    // 古いログ削除
    return lr.cleanOldLogs(logFile)
}
```

### 3.3 ログ転送

#### バッチ送信処理

```go
type LogSender struct {
    endpoint   string
    batchSize  int
    interval   time.Duration
    buffer     []LogEntry
    mu         sync.Mutex
}

func (ls *LogSender) Start(ctx context.Context) {
    ticker := time.NewTicker(ls.interval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            ls.flush()
        }
    }
}

func (ls *LogSender) flush() error {
    ls.mu.Lock()
    defer ls.mu.Unlock()
    
    if len(ls.buffer) == 0 {
        return nil
    }
    
    // バッチ作成
    batch := LogBatch{
        Timestamp: time.Now(),
        Logs:      ls.buffer,
        Count:     len(ls.buffer),
    }
    
    // JSON化
    data, err := json.Marshal(batch)
    if err != nil {
        return err
    }
    
    // 送信（リトライ付き）
    for i := 0; i < 3; i++ {
        if err := ls.send(data); err == nil {
            ls.buffer = nil
            return nil
        }
        time.Sleep(time.Second * time.Duration(i+1))
    }
    
    // 失敗時はローカル保存
    return ls.saveLocal(data)
}
```

---

## 4. 状態管理

### 4.1 state.json構造

```json
{
  "system": {
    "startTime": "2025-07-26T00:00:00+09:00",
    "uptime": 86400,
    "version": "1.0.0"
  },
  "services": {
    "caddy": {
      "status": "running",
      "pid": 1234,
      "startTime": "2025-07-26T00:00:00+09:00"
    },
    "api": {
      "status": "running",
      "pid": 5678,
      "startTime": "2025-07-26T00:00:00+09:00"
    }
  },
  "metrics": {
    "totalRequests": 123456,
    "totalBytes": 1234567890,
    "errorCount": 12,
    "lastUpdate": "2025-07-26T12:34:56+09:00"
  },
  "sessions": {
    "active": 3,
    "total": 123
  }
}
```

### 4.2 メトリクス収集

```go
type MetricsCollector struct {
    state    *State
    interval time.Duration
}

func (mc *MetricsCollector) Collect() {
    ticker := time.NewTicker(mc.interval)
    defer ticker.Stop()
    
    for range ticker.C {
        mc.updateCPU()
        mc.updateMemory()
        mc.updateNetwork()
        mc.updateDisk()
        mc.save()
    }
}
```

---

## 5. キャッシュ管理

### 5.1 キャッシュ戦略

| 種別 | TTL | 最大サイズ | 削除ポリシー |
|------|-----|-----------|-------------|
| 設定キャッシュ | 無期限 | - | 手動無効化 |
| ルーティングキャッシュ | 5分 | 1000エントリ | LRU |
| 証明書キャッシュ | 1時間 | 100エントリ | TTL |
| メトリクスキャッシュ | 1分 | - | TTL |

### 5.2 キャッシュ実装

```go
type Cache struct {
    data map[string]CacheEntry
    lru  *list.List
    mu   sync.RWMutex
    max  int
}

type CacheEntry struct {
    key       string
    value     interface{}
    expiry    time.Time
    element   *list.Element
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    entry, ok := c.data[key]
    if !ok {
        return nil, false
    }
    
    if time.Now().After(entry.expiry) {
        go c.Delete(key)
        return nil, false
    }
    
    // LRU更新
    c.lru.MoveToFront(entry.element)
    
    return entry.value, true
}
```

---

## 6. データ整合性

### 6.1 トランザクション管理

```go
type Transaction struct {
    id       string
    changes  []Change
    rollback []func() error
}

func (t *Transaction) Execute() error {
    for i, change := range t.changes {
        if err := change.Apply(); err != nil {
            // ロールバック
            for j := i - 1; j >= 0; j-- {
                t.rollback[j]()
            }
            return err
        }
    }
    return t.Commit()
}
```

### 6.2 並行制御

```go
type ConfigLock struct {
    readers int32
    writer  int32
    mu      sync.Mutex
}

func (cl *ConfigLock) RLock() {
    for atomic.LoadInt32(&cl.writer) > 0 {
        time.Sleep(time.Millisecond)
    }
    atomic.AddInt32(&cl.readers, 1)
}

func (cl *ConfigLock) Lock() {
    cl.mu.Lock()
    defer cl.mu.Unlock()
    
    atomic.StoreInt32(&cl.writer, 1)
    for atomic.LoadInt32(&cl.readers) > 0 {
        time.Sleep(time.Millisecond)
    }
}
```

---

## 7. データ移行

### 7.1 マイグレーション管理

```go
type Migration struct {
    Version     string
    Description string
    Up          func(*Config) error
    Down        func(*Config) error
}

var migrations = []Migration{
    {
        Version:     "1.0.0",
        Description: "初期スキーマ",
        Up:          migrateV1_0_0,
    },
    {
        Version:     "1.1.0",
        Description: "オプション項目追加",
        Up:          migrateV1_1_0,
    },
}
```

### 7.2 バージョンアップ処理

```go
func MigrateConfig(config *Config, targetVersion string) error {
    currentVersion := config.Version
    
    for _, migration := range migrations {
        if compareVersion(currentVersion, migration.Version) < 0 &&
           compareVersion(migration.Version, targetVersion) <= 0 {
            
            log.Printf("マイグレーション実行: %s", migration.Description)
            if err := migration.Up(config); err != nil {
                return fmt.Errorf("マイグレーション失敗 %s: %w", 
                    migration.Version, err)
            }
            
            config.Version = migration.Version
        }
    }
    
    return nil
}
```

---

## 8. パフォーマンス最適化

### 8.1 インデックス

メモリ内インデックスを構築して高速検索を実現：

```go
type Index struct {
    domainIndex map[string]*Domain
    pathIndex   map[string]map[string]*Rule  // domain -> path -> rule
    ipIndex     map[string][]*Rule
}

func (idx *Index) Build(config *Config) {
    idx.domainIndex = make(map[string]*Domain)
    idx.pathIndex = make(map[string]map[string]*Rule)
    idx.ipIndex = make(map[string][]*Rule)
    
    // インデックス構築
    for domain, subnet := range config.Hostdomains {
        idx.domainIndex[domain] = &Domain{
            Name:   domain,
            Subnet: subnet,
        }
    }
    
    for domain, paths := range config.Hostingdevice {
        idx.pathIndex[domain] = make(map[string]*Rule)
        for path, rule := range paths {
            idx.pathIndex[domain][path] = rule
            
            // IPインデックス
            if rule.DeviceIP != "" {
                idx.ipIndex[rule.DeviceIP] = append(
                    idx.ipIndex[rule.DeviceIP], rule)
            }
        }
    }
}
```

### 8.2 バッチ処理

```go
type BatchProcessor struct {
    batchSize int
    interval  time.Duration
    processor func([]interface{}) error
}

func (bp *BatchProcessor) Process(items []interface{}) error {
    for i := 0; i < len(items); i += bp.batchSize {
        end := i + bp.batchSize
        if end > len(items) {
            end = len(items)
        }
        
        batch := items[i:end]
        if err := bp.processor(batch); err != nil {
            return fmt.Errorf("バッチ処理エラー: %w", err)
        }
        
        // レート制限
        if end < len(items) {
            time.Sleep(bp.interval)
        }
    }
    
    return nil
}
```

---

## 9. 監視・アラート

### 9.1 データ異常検知

```go
type DataValidator struct {
    rules []ValidationRule
}

type ValidationRule struct {
    Name     string
    Check    func(*Config) error
    Severity string  // "critical", "warning", "info"
}

func (dv *DataValidator) Validate(config *Config) []ValidationError {
    var errors []ValidationError
    
    for _, rule := range dv.rules {
        if err := rule.Check(config); err != nil {
            errors = append(errors, ValidationError{
                Rule:     rule.Name,
                Error:    err,
                Severity: rule.Severity,
            })
        }
    }
    
    return errors
}
```

### 9.2 監視メトリクス

| メトリクス | 閾値 | アラート条件 |
|-----------|------|-------------|
| 設定ファイルサイズ | 10MB | 超過時に警告 |
| ログファイルサイズ | 300KB | ローテーション実行 |
| バックアップ数 | 5 | 古いものから削除 |
| メモリ使用量 | 1GB | 警告通知 |
| 設定変更頻度 | 10回/時 | 異常検知 |

---

## 10. セキュリティ

### 10.1 アクセス制御

```go
type AccessControl struct {
    permissions map[string][]string  // user -> permissions
}

func (ac *AccessControl) CheckPermission(user, action string) bool {
    perms, ok := ac.permissions[user]
    if !ok {
        return false
    }
    
    for _, perm := range perms {
        if perm == action || perm == "*" {
            return true
        }
    }
    
    return false
}
```

### 10.2 暗号化

機密データの暗号化：

```go
type Encryptor struct {
    key []byte
}

func (e *Encryptor) EncryptField(field string) (string, error) {
    block, err := aes.NewCipher(e.key)
    if err != nil {
        return "", err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }
    
    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }
    
    ciphertext := gcm.Seal(nonce, nonce, []byte(field), nil)
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}
```

---

## 変更履歴

| バージョン | 日付 | 変更内容 | 作成者 |
|-----------|------|----------|--------|
| 1.0.0 | 2025-07-26 | 初版作成 | System | 